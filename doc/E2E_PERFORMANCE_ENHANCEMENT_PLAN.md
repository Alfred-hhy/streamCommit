# VDS 端到端性能测试增强方案

## 📋 现状分析

### 已有的测试内容

当前 `doc/e2e_performance_benchmark.py` 已经实现了以下测试：

1. ✅ **批次创建性能** - DO.create_batch() + SS.store_batch()
2. ✅ **DC 查询性能** - SS.generate_dc_data_proof() + Verifier.verify_dc_query()
3. ✅ **DA 审计性能** - SS.generate_da_audit_proof() + Verifier.verify_da_audit()
4. ✅ **批次撤销性能** - DO.revoke_batch() + SS/Verifier 更新
5. ✅ **时间范围证明性能** - SS.generate_time_range_proofs() + Verifier 验证
6. ✅ **带宽/通信开销** - 所有操作的数据大小测量

### 缺失的测试内容

❌ **批次更新性能** - DO.update_batch() + SS.update_batch() 的完整流程  
❌ **多维数据性能** - 多列数据的创建、查询、审计性能  
❌ **批次大小对比** - 细粒度批次 vs 粗粒度批次的性能对比  
❌ **连续更新性能** - 多次连续更新的性能退化分析  

---

## 🎯 增强目标

### 目标 1: 添加批次更新性能测试

**测试内容**:
```python
def benchmark_batch_update(self, vector_sizes: List[int], num_runs=10):
    """
    测试流程：
    1. DO 创建初始批次
    2. SS 存储初始批次
    3. DO 更新批次 (update_batch)
    4. SS 更新批次 (update_batch)
    5. Verifier 更新全局公钥
    6. 验证新批次有效
    7. 验证旧批次失效
    """
```

**测量指标**:
- DO.update_batch() 时间（包含撤销 + 创建）
- SS.update_batch() 时间（包含删除 + 存储）
- Verifier.update_global_pk() 时间
- 验证新批次时间
- 验证旧批次失效时间
- 总时间
- 新批次数据大小
- 撤销数据大小（g_s_q_new, sigma_bytes）

**关键发现**:
- 更新操作 vs 创建操作的性能对比
- 更新操作的主要瓶颈（撤销 vs 创建）
- 更新操作的通信开销

---

### 目标 2: 添加多维数据性能测试

**测试内容**:
```python
def benchmark_multidim_batch(self, vector_sizes: List[int], 
                             num_columns: List[int], num_runs=10):
    """
    测试流程：
    1. 创建多列批次（1列、3列、5列）
    2. 查询不同列的数据
    3. 审计不同列的数据
    4. 更新多列批次
    """
```

**测量指标**:
- 创建时间 vs 列数
- 查询时间 vs 列数
- 审计时间 vs 列数
- 更新时间 vs 列数
- 数据大小 vs 列数
- 证明大小 vs 列数

**关键发现**:
- 多列共享签名的性能优势
- 列数对性能的影响
- 多列 vs 多批次的性能对比

---

### 目标 3: 添加批次粒度对比测试

**测试内容**:
```python
def benchmark_batch_granularity(self, total_data_points=1000, num_runs=10):
    """
    对比不同批次划分策略：
    - 策略 1: 1 个大批次（n=1000）
    - 策略 2: 10 个中批次（n=100）
    - 策略 3: 100 个小批次（n=10）
    
    测试场景：修改 1 个数据点
    """
```

**测量指标**:
- 创建总时间
- 更新 1 个数据点的时间
- 总存储开销
- 总签名数量
- 查询性能

**关键发现**:
- 细粒度批次的更新优势
- 粗粒度批次的存储优势
- 最优批次大小建议

---

### 目标 4: 添加连续更新性能测试

**测试内容**:
```python
def benchmark_consecutive_updates(self, vector_sizes: List[int], 
                                  num_updates: int = 10, num_runs=10):
    """
    测试流程：
    1. 创建初始批次
    2. 连续更新 10 次
    3. 测量每次更新的性能
    4. 分析性能退化
    """
```

**测量指标**:
- 每次更新的时间
- 累加器大小增长
- 黑名单大小增长
- 验证时间增长
- 性能退化率

**关键发现**:
- 更新次数对性能的影响
- 累加器增长对验证性能的影响
- 黑名单管理的性能开销

---

## 📊 新增可视化图表

### 图表 1: `e2e_batch_update.png`
- **内容**: 批次更新的各个阶段性能
- **X 轴**: 向量大小 (n)
- **Y 轴**: 时间 (ms)
- **柱状图**: DO 更新、SS 更新、Verifier 更新、验证新批次、验证旧批次失效

### 图表 2: `e2e_multidim_performance.png`
- **内容**: 多维数据性能对比
- **X 轴**: 列数 (1, 3, 5)
- **Y 轴**: 时间 (ms)
- **柱状图**: 创建、查询、审计、更新

### 图表 3: `e2e_batch_granularity.png`
- **内容**: 批次粒度对比
- **X 轴**: 批次策略（大/中/小）
- **Y 轴**: 时间 (ms)
- **柱状图**: 创建总时间、更新 1 个数据点时间

### 图表 4: `e2e_consecutive_updates.png`
- **内容**: 连续更新性能退化
- **X 轴**: 更新次数 (1-10)
- **Y 轴**: 时间 (ms)
- **折线图**: 更新时间、验证时间

### 图表 5: `e2e_comprehensive_summary.png`
- **内容**: 综合性能摘要（更新版）
- **X 轴**: 向量大小 (n)
- **Y 轴**: 时间 (ms)
- **柱状图**: 创建、查询、审计、撤销、更新、时间证明

---

## 🔧 实现计划

### 阶段 1: 修改 `e2e_performance_benchmark.py`

**新增方法**:
1. `benchmark_batch_update()` - 批次更新性能测试
2. `benchmark_multidim_batch()` - 多维数据性能测试
3. `benchmark_batch_granularity()` - 批次粒度对比测试
4. `benchmark_consecutive_updates()` - 连续更新性能测试

**修改方法**:
- `print_summary()` - 添加新测试的摘要输出
- `save_results()` - 保存新测试的结果

### 阶段 2: 修改 `e2e_performance_analysis.py`

**新增方法**:
1. `plot_batch_update()` - 绘制批次更新性能图
2. `plot_multidim_performance()` - 绘制多维数据性能图
3. `plot_batch_granularity()` - 绘制批次粒度对比图
4. `plot_consecutive_updates()` - 绘制连续更新性能图
5. `plot_comprehensive_summary()` - 绘制综合摘要图（更新版）

**修改方法**:
- `generate_all_plots()` - 调用所有新增的绘图方法

### 阶段 3: 更新文档

**修改文件**:
- `doc/E2E_PERFORMANCE_GUIDE.md` - 添加新测试的说明
- 创建 `doc/E2E_PERFORMANCE_RESULTS.md` - 详细的测试结果分析

---

## 📝 预期输出示例

```
🚀 VDS Scheme C+ 端到端性能基准测试（增强版）
======================================================================

📋 测试配置:
   - 向量大小: [4, 8, 16, 32]
   - 列数: [1, 3, 5]
   - 每个测试重复: 10 次
   - 曲线: MNT224

📊 批次更新端到端性能测试 (每个测试重复 10 次)
======================================================================
  测试 n=4... ✓ DO:18.45±0.52ms SS:3.12±0.15ms Ver:1.23±0.08ms 总:22.80±0.55ms
  测试 n=8... ✓ DO:34.56±0.78ms SS:4.23±0.18ms Ver:1.45±0.09ms 总:40.24±0.81ms
  测试 n=16... ✓ DO:65.78±1.23ms SS:5.67±0.23ms Ver:1.78±0.11ms 总:73.23±1.27ms

📊 多维数据性能测试 (每个测试重复 10 次)
======================================================================
  测试 n=8, 列数=1... ✓ 创建:31.57±0.69ms 查询:39.12±0.66ms
  测试 n=8, 列数=3... ✓ 创建:87.34±1.45ms 查询:39.45±0.68ms
  测试 n=8, 列数=5... ✓ 创建:142.67±2.12ms 查询:39.78±0.71ms

📊 批次粒度对比测试 (总数据点=1000)
======================================================================
  策略 1 (1×1000)... ✓ 创建:456.78ms 更新1点:458.23ms
  策略 2 (10×100)... ✓ 创建:478.34ms 更新1点:47.89ms
  策略 3 (100×10)... ✓ 创建:512.45ms 更新1点:5.23ms

📊 连续更新性能测试 (n=8, 更新10次)
======================================================================
  更新 1... ✓ 40.24±0.81ms
  更新 2... ✓ 40.67±0.83ms
  更新 3... ✓ 41.12±0.85ms
  ...
  更新 10... ✓ 43.45±0.92ms
  性能退化: 8.0%
```

---

## ✅ 验收标准

1. ✅ 所有新增测试方法正常运行
2. ✅ 所有测试结果保存到 JSON 文件
3. ✅ 所有新增图表正常生成
4. ✅ 文档更新完整
5. ✅ 测试结果符合预期（更新比创建稍慢，多列共享签名有优势等）

---

## 🚀 下一步行动

**请确认以下问题**:

1. **测试范围**: 是否需要添加/删除某些测试？
2. **测试参数**: 向量大小 [4, 8, 16, 32] 是否合适？
3. **重复次数**: 每个测试重复 10 次是否足够？
4. **图表样式**: 是否有特殊的可视化需求？

**确认后我将开始实现**:
1. 修改 `e2e_performance_benchmark.py`
2. 修改 `e2e_performance_analysis.py`
3. 更新文档
4. 运行测试并生成图表

