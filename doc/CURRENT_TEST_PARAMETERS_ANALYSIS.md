# 当前测试参数详细分析

## 📊 测试 1: 基础性能测试 (`doc/performance_benchmark.py`)

### 测试参数
```python
vector_sizes = [4, 8, 16, 32]  # 向量大小
num_runs = 10                   # 每个测试重复 10 次
curve = 'MNT224'                # 椭圆曲线
```

### 测试内容

#### 1. CRS 生成测试
- **测试什么**: 生成公共参考字符串 (g, g₁, g₂, ..., gₙ, ĝ, ĝ₁, ..., ĝₙ)
- **测试次数**: 每个 n 值测试 10 次
- **向量大小**: n ∈ {4, 8, 16, 32}
- **数据点总数**: 4 个不同的 n 值
- **总测试次数**: 4 × 10 = 40 次

#### 2. 承诺生成测试
- **测试什么**: 
  - `commit_G(m, γ, crs)` - 数据承诺（G1 群）
  - `commit_Ghat(t, γ, crs)` - 时间承诺（G2 群）
  - `commit_Cy(y, crs)` - 辅助承诺
  - `commit_V(V, crs)` - 向量承诺
- **测试次数**: 每个承诺类型、每个 n 值测试 10 次
- **向量大小**: n ∈ {4, 8, 16, 32}
- **数据点总数**: 4 个 n 值 × 4 种承诺 = 16 组测试
- **总测试次数**: 16 × 10 = 160 次

#### 3. 证明生成测试
- **测试什么**:
  - `point_open` - 单点打开证明
  - `agg_open` - 聚合打开证明
  - `equality` - 相等性证明
  - `orthogonality` - 正交性证明
  - `range` - 范围证明
- **测试次数**: 每个证明类型、每个 n 值测试 10 次
- **向量大小**: n ∈ {4, 8, 16, 32}
- **数据点总数**: 4 个 n 值 × 5 种证明 = 20 组测试
- **总测试次数**: 20 × 10 = 200 次

#### 4. 验证测试
- **测试什么**: 验证上述所有证明
- **测试次数**: 每个验证、每个 n 值测试 10 次
- **向量大小**: n ∈ {4, 8, 16, 32}
- **数据点总数**: 4 个 n 值 × 5 种验证 = 20 组测试
- **总测试次数**: 20 × 10 = 200 次

#### 5. 带宽测试
- **测试什么**: 序列化后的字节大小
  - Header Size (承诺大小)
  - Proof Size (证明大小)
  - Raw Data Size (原始数据大小)
- **测试次数**: 每个 n 值测试 1 次（大小是确定的）
- **向量大小**: n ∈ {4, 8, 16, 32}
- **数据点总数**: 4 个 n 值

### 测试数据特征

```python
# 数据向量 m
m_vector = [group.init(ZR, i + 10) for i in range(n)]
# n=4:  m = [10, 11, 12, 13]
# n=8:  m = [10, 11, 12, 13, 14, 15, 16, 17]
# n=16: m = [10, 11, ..., 25]
# n=32: m = [10, 11, ..., 41]

# 时间向量 t
t_vector = [group.init(ZR, i + 1) for i in range(n)]
# n=4:  t = [1, 2, 3, 4]
# n=8:  t = [1, 2, 3, 4, 5, 6, 7, 8]
# n=16: t = [1, 2, ..., 16]
# n=32: t = [1, 2, ..., 32]
```

**关键观察**:
- ❌ 时间只是简单的序号 [1, 2, 3, ...]，不是真实的时间戳
- ❌ 数据是简单的递增序列 [10, 11, 12, ...]，不是真实的传感器数据
- ✅ 但这不影响性能测试的有效性（密码学操作不关心数据内容）

### 总结

| 指标 | 值 |
|------|-----|
| **向量大小范围** | 4 - 32 |
| **最大数据点数** | 32 个 |
| **每个测试重复次数** | 10 次 |
| **总测试组数** | 约 60 组 |
| **总测试次数** | 约 600 次 |
| **测试时间** | 约 2-5 分钟 |

---

## 📊 测试 2: 端到端性能测试 (`doc/e2e_performance_benchmark.py`)

### 测试参数
```python
vector_sizes = [4, 8, 16]  # 向量大小（比基础测试少）
num_runs = 10              # 每个测试重复 10 次
curve = 'MNT224'           # 椭圆曲线
```

### 测试内容

#### 1. 批次创建测试
- **测试什么**: DO.create_batch() + SS.store_batch()
- **测试次数**: 每个 n 值测试 10 次
- **向量大小**: n ∈ {4, 8, 16}
- **数据点总数**: 3 个 n 值
- **总测试次数**: 3 × 10 = 30 次

#### 2. DC 查询测试
- **测试什么**: SS.generate_dc_data_proof() + Verifier.verify_dc_query()
- **测试次数**: 每个 n 值测试 10 次
- **向量大小**: n ∈ {4, 8, 16}
- **查询向量**: t_query = [1, 1, ..., 1]（求和）
- **总测试次数**: 3 × 10 = 30 次

#### 3. DA 审计测试
- **测试什么**: SS.generate_da_audit_proof() + Verifier.verify_da_audit()
- **测试次数**: 每个 n 值测试 10 次
- **向量大小**: n ∈ {4, 8, 16}
- **总测试次数**: 3 × 10 = 30 次

#### 4. 批次撤销测试
- **测试什么**: DO.revoke_batch() + SS/Verifier 更新 + 验证失败
- **测试次数**: 每个 n 值测试 10 次
- **向量大小**: n ∈ {4, 8, 16}
- **总测试次数**: 3 × 10 = 30 次

#### 5. 时间范围证明测试
- **测试什么**: SS.generate_time_range_proofs() + Verifier 验证
- **测试次数**: 每个 n 值测试 10 次
- **向量大小**: n ∈ {4, 8, 16}
- **总测试次数**: 3 × 10 = 30 次

### 总结

| 指标 | 值 |
|------|-----|
| **向量大小范围** | 4 - 16 |
| **最大数据点数** | 16 个 |
| **每个测试重复次数** | 10 次 |
| **总测试组数** | 5 个工作流 × 3 个 n 值 = 15 组 |
| **总测试次数** | 15 × 10 = 150 次 |
| **测试时间** | 约 3-8 分钟 |

---

## 🔍 关键问题总结

### 问题 1: 数据量太小
- **当前**: 最大 n=32（32 个数据点）
- **真实场景**: n=1000-10000（每分钟采样，持续几天）
- **影响**: 无法测试大规模数据的性能

### 问题 2: 时间不是真实时间戳
- **当前**: t = [1, 2, 3, ...]（简单序号）
- **真实场景**: t = [1699876543, 1699880143, ...]（Unix timestamp）
- **影响**: 不影响性能测试，但不够真实

### 问题 3: 不是真正的端到端
- **当前**: 所有角色在同一进程，直接函数调用
- **真实场景**: 多进程/多机器，HTTP 通信
- **影响**: 无法测试网络延迟、序列化开销

---

## 💡 改进建议

### 短期改进（立即可做）
1. **增加数据量**: `vector_sizes = [8, 16, 32, 64, 128, 256, 512, 1024]`
2. **使用真实时间戳**: `t = [base_time + i*60 for i in range(n)]`
3. **添加序列化测试**: 测量 JSON/Pickle 序列化时间

### 中期改进（需要开发）
1. **实现 HTTP API**: Flask/FastAPI
2. **多进程测试**: subprocess/multiprocessing
3. **测量网络开销**: 序列化 + HTTP 传输时间

### 长期改进（需要基础设施）
1. **Docker Compose**: 容器化部署
2. **网络延迟模拟**: tc 命令
3. **真实多机器部署**: 云端测试

